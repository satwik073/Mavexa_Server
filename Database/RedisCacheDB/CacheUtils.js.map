{"version":3,"file":"CacheUtils.js","sourceRoot":"/","sources":["Database/RedisCacheDB/CacheUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { SetOptions } from \"redis\";\r\nimport { redisClusterConnection } from \"./RedisConfigurations\";\r\n\r\nconst parsingTheDataJSONValues = (dataBufferingRequest: Buffer | null): any | null => {\r\n    try {\r\n        return (!dataBufferingRequest) ? null : (JSON.parse(dataBufferingRequest.toString()))\r\n    } catch (error_value: any) {\r\n        console.error('Error in Parsing the JSON Data from Cache', error_value)\r\n        return null\r\n    }\r\n}\r\n\r\nexport const retrieveCachedDataWithPerformanceMetricsAndSafety = async (cacheKeyIdentifierString: string): Promise<any> => {\r\n    const cacheRetrievalStartTimestamp: number = Date.now();\r\n    try {\r\n        const cachedDataBuffer: Buffer | null = await redisClusterConnection.getBuffer(cacheKeyIdentifierString);\r\n        const parsedData = parsingTheDataJSONValues(cachedDataBuffer);\r\n        return parsedData\r\n    } catch (error) {\r\n        console.error(`An error occurred while attempting to fetch cache for key: ${cacheKeyIdentifierString}`, error);\r\n        return null;\r\n    }\r\n    finally {\r\n        const cacheRetrievalEndTimestamp: number = Date.now();\r\n        const cacheRetrievalDurationInMilliseconds: number = cacheRetrievalEndTimestamp - cacheRetrievalStartTimestamp;\r\n        console.log(`[PERFORMANCE] Cache GET operation for key \"${cacheKeyIdentifierString}\" took ${cacheRetrievalDurationInMilliseconds}ms`);\r\n    }\r\n}\r\n\r\n\r\nexport const setCacheWithAdvancedTTLHandlingAndPipelining = async (\r\n    cacheKeyIdentifierString: string,  // Cache key\r\n    cacheValueObjectToStore: any,      // Value to cache (object)\r\n    cacheTimeToLiveInSeconds?: number  // TTL in seconds (optional)\r\n): Promise<void> => {\r\n    const cacheSetOperationStartTimestamp: number = Date.now();\r\n    \r\n    try {\r\n        // Step 1: Serialize the object into a string (JSON)\r\n        const serializedCacheValueString: string = JSON.stringify(cacheValueObjectToStore);\r\n        \r\n        // Step 2: Ensure Redis connection is ready\r\n        if (!redisClusterConnection || redisClusterConnection.status !== 'ready') {\r\n            console.error('Redis connection is not initialized or ready.');\r\n            await redisClusterConnection.connect();  // Manually trigger connection if needed\r\n        }\r\n\r\n        // Step 3: Use Redis pipeline or direct `set` depending on preference\r\n        const pipelineInstanceForSettingCacheData = redisClusterConnection.pipeline();\r\n        \r\n        // If TTL is provided, set with expiration; otherwise, set without expiration\r\n        if (cacheTimeToLiveInSeconds) {\r\n            // Using expiration 'EX' and TTL (in seconds)\r\n            pipelineInstanceForSettingCacheData.set(\r\n                cacheKeyIdentifierString,\r\n                serializedCacheValueString,\r\n                'EX', cacheTimeToLiveInSeconds\r\n            );\r\n        } else {\r\n            // Set without expiration\r\n            pipelineInstanceForSettingCacheData.set(\r\n                cacheKeyIdentifierString,\r\n                serializedCacheValueString\r\n            );\r\n        }\r\n\r\n        // Step 4: Execute the pipeline (or direct set)\r\n        await pipelineInstanceForSettingCacheData.exec();\r\n        console.log(`Cache set for key \"${cacheKeyIdentifierString}\" successfully.`);\r\n\r\n    } catch (error) {\r\n        console.error(`An error occurred while setting cache for key: ${cacheKeyIdentifierString}`, error);\r\n        throw error;  // Re-throw the error to handle it higher up the call stack\r\n    } finally {\r\n        const cacheSetOperationEndTimestamp: number = Date.now();\r\n        const cacheSetOperationDurationInMilliseconds: number = cacheSetOperationEndTimestamp - cacheSetOperationStartTimestamp;\r\n        console.log(`[PERFORMANCE] Cache SET operation for key \"${cacheKeyIdentifierString}\" took ${cacheSetOperationDurationInMilliseconds}ms`);\r\n    }\r\n};\r\n\r\nexport const deleteCacheKeyWithDetailedPerformanceMetrics = async (cacheKeyIdentifierString: string): Promise<void> => {\r\n    const cacheDeletionStartTimestamp: number = Date.now();\r\n    try {\r\n        await redisClusterConnection.del(cacheKeyIdentifierString);\r\n    } catch (error) {\r\n        console.error(`An error occurred while attempting to delete cache for key: ${cacheKeyIdentifierString}`, error);\r\n    } finally {\r\n        const cacheDeletionEndTimestamp: number = Date.now();\r\n        const cacheDeletionDurationInMilliseconds: number = cacheDeletionEndTimestamp - cacheDeletionStartTimestamp;\r\n        console.log(`[PERFORMANCE] Cache DEL operation for key \"${cacheKeyIdentifierString}\" took ${cacheDeletionDurationInMilliseconds}ms`);\r\n    }\r\n};\r\n\r\nexport const deleteMultipleCacheKeysWithAdvancedPipeliningAndLogging = async (cacheKeyIdentifierArray: string[]): Promise<void> => {\r\n    const batchCacheDeletionStartTimestamp: number = Date.now();\r\n    try {\r\n        if (cacheKeyIdentifierArray.length === 0) return;\r\n\r\n        const pipelineInstanceForBatchDeletion = redisClusterConnection.pipeline();\r\n        cacheKeyIdentifierArray.forEach((cacheKeyIdentifierString) => pipelineInstanceForBatchDeletion.del(cacheKeyIdentifierString));\r\n\r\n        await pipelineInstanceForBatchDeletion.exec();\r\n    } catch (error) {\r\n        console.error('An error occurred while attempting to delete multiple cache keys in batch:', error);\r\n    } finally {\r\n        const batchCacheDeletionEndTimestamp: number = Date.now();\r\n        const batchCacheDeletionDurationInMilliseconds: number = batchCacheDeletionEndTimestamp - batchCacheDeletionStartTimestamp;\r\n        console.log(`[PERFORMANCE] Batch Cache DEL operation for multiple keys took ${batchCacheDeletionDurationInMilliseconds}ms`);\r\n    }\r\n};"]}