{"version":3,"file":"userControllersGenerated.js","sourceRoot":"/","sources":["Controllers/user_controllers/userControllersGenerated.ts"],"names":[],"mappings":"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","sourcesContent":["import { Request, response, Response } from \"express\";\r\nconst bcrypt = require('bcryptjs');\r\nimport { email_service_enabled } from \"../../Services/EmailServices\";\r\nimport { ASYNC_ERROR_HANDLER_ESTAIBLISHED, EXISTING_USER_FOUND_IN_DATABASE, MISSING_FIELDS_VALIDATOR, TRACKING_DATA_OBJECT } from \"../../Middlewares/Error/ErrorHandlerReducer\";\r\nimport RolesSpecified, { AuthTypeDeclared, UserDocument } from \"../../Common/structure\";\r\nimport { DECODING_INCOMING_SECURITY_PASSCODE, JWT_KEY_GENERATION_ONBOARDED, OTP_GENERATOR_CALLED, SECURING_PASSCODE } from \"../../Constants/Functions/CommonFunctions\";\r\nimport { DEFAULT_EXECUTED, ERROR_VALUES_FETCHER } from \"../../Constants/Errors/PreDefinedErrors\";\r\nimport HTTPS_STATUS_CODE from \"http-status-codes\";\r\nimport { SUCCESS_VALUES_FETCHER } from \"../../Constants/Success/PreDefinedSuccess\";\r\nimport { redisClusterConnection } from \"../../Database/RedisCacheDB/RedisConfigurations\";\r\nimport { setCacheWithAdvancedTTLHandlingAndPipelining } from \"../../Database/RedisCacheDB/CacheUtils\";\r\nimport { userInfo } from \"os\";\r\n\r\n\r\n\r\n\r\ninterface UserRegisterRequest {\r\n    registered_username: string;\r\n    registered_user_email: string;\r\n    registered_user_password: string;\r\n}\r\n\r\ninterface AuthenticatedRequest extends Request {\r\n    user?: any;\r\n}\r\ninterface UserLoginRequest {\r\n    registered_user_email: string;\r\n    registered_user_password: string;\r\n}\r\ninterface UserVerificationMethod {\r\n    otp_for_verification: string\r\n}\r\n\r\n// Example usage\r\n// const deleteCache = async () => {\r\n//     try {\r\n//         const result = await request?.redisClient?.del(`user:${registered_user_email}`);\r\n//         console.log(`Deleted ${result} key(s) from cache`);\r\n//     } catch (err) {\r\n//         console.error('Error deleting key:', err);\r\n//     }\r\n// };\r\n// deleteCache()\r\nexport const UserRegistrationProcess = ASYNC_ERROR_HANDLER_ESTAIBLISHED(async (request: Request<{}, {}, UserRegisterRequest>, response: Response) => {\r\n    const { registered_username, registered_user_email, registered_user_password } = request.body;\r\n    const missingFields = MISSING_FIELDS_VALIDATOR(\r\n        { registered_user_email, registered_user_password },\r\n        response,\r\n        AuthTypeDeclared.USER_REGISTRATION\r\n    );\r\n    if (missingFields) return missingFields;\r\n\r\n    await EXISTING_USER_FOUND_IN_DATABASE(registered_user_email, AuthTypeDeclared.USER_REGISTRATION, RolesSpecified.USER_DESC);\r\n    const otpCaptured = OTP_GENERATOR_CALLED(registered_user_email);\r\n    const manipulatedPasscode = SECURING_PASSCODE(registered_user_password);\r\n\r\n    const {\r\n        recognized_user: userRegistrationData,\r\n        token_for_authentication_generated: tokenFetched\r\n    } = await TRACKING_DATA_OBJECT(\r\n        {\r\n            registered_user_email,\r\n            registered_username,\r\n            registered_user_password: manipulatedPasscode,\r\n            otp_for_verification: otpCaptured\r\n        },\r\n        RolesSpecified.USER_DESC\r\n    );\r\n\r\n    const cacheKey = `user:${userRegistrationData.id}`;\r\n    try {\r\n        await setCacheWithAdvancedTTLHandlingAndPipelining(cacheKey, userRegistrationData, 3600);\r\n    } catch (redisError) {\r\n        console.error('Failed to store user registration data in Redis:', redisError);\r\n    }\r\n\r\n    return response.status(HTTPS_STATUS_CODE.OK).json({\r\n        success: true,\r\n        message: [\r\n            {\r\n                SUCCESS_MESSAGE: SUCCESS_VALUES_FETCHER.ENTITY_ONBOARDED_FULFILED(\r\n                    AuthTypeDeclared.USER_REGISTRATION,\r\n                    RolesSpecified.USER_DESC\r\n                ).SUCCESS_MESSAGE,\r\n                USER_ROLE: RolesSpecified.USER_DESC,\r\n                AUTH_TYPE: AuthTypeDeclared.USER_REGISTRATION\r\n            },\r\n        ],\r\n        userInfo: userRegistrationData,\r\n        token: tokenFetched\r\n    });\r\n});\r\n\r\nexport const letting_user_registered = async (request: Request<{}, {}, UserRegisterRequest>, response: Response) => {\r\n    try {\r\n\r\n        const { registered_username, registered_user_email, registered_user_password } = request.body;\r\n        const is_exists_missing_fields = MISSING_FIELDS_VALIDATOR({ registered_user_email, registered_user_password, registered_username }, response, AuthTypeDeclared.USER_REGISTRATION)\r\n        if (is_exists_missing_fields) return is_exists_missing_fields\r\n        await EXISTING_USER_FOUND_IN_DATABASE(registered_user_email, AuthTypeDeclared.USER_REGISTRATION, RolesSpecified.USER_DESC)\r\n        const otp_generating_code_block = await OTP_GENERATOR_CALLED(registered_user_email)\r\n        const hashed_password_generated = await SECURING_PASSCODE(registered_user_password);\r\n\r\n        const { recognized_user: new_registered_user_defined, token_for_authentication_generated } = await TRACKING_DATA_OBJECT({ registered_user_email, registered_username, registered_user_password: hashed_password_generated, otp_for_verification: otp_generating_code_block }, RolesSpecified.USER_DESC);\r\n        console.log(new_registered_user_defined.id)\r\n        const cacheKey = `user:${new_registered_user_defined.id}`;\r\n        try {\r\n            setCacheWithAdvancedTTLHandlingAndPipelining(cacheKey, new_registered_user_defined, 3600);\r\n        } catch (redisError) {\r\n            console.error('Failed to store user registration data in Redis:', redisError);\r\n        }\r\n        return response.status(HTTPS_STATUS_CODE.OK).json({\r\n            success: true,\r\n            message: [\r\n                {\r\n                    SUCCESS_MESSAGE: SUCCESS_VALUES_FETCHER.ENTITY_ONBOARDED_FULFILED(AuthTypeDeclared.USER_REGISTRATION, RolesSpecified.USER_DESC).SUCCESS_MESSAGE,\r\n                    USER_ROLE: RolesSpecified.USER_DESC,\r\n                    AUTH_TYPE: AuthTypeDeclared.USER_REGISTRATION\r\n                },\r\n\r\n            ],\r\n            userInfo: new_registered_user_defined,\r\n            token: token_for_authentication_generated\r\n        });\r\n    } catch (error_value_displayed) {\r\n        console.error(\"Error in user registration:\", error_value_displayed);\r\n        return response.status(HTTPS_STATUS_CODE.INTERNAL_SERVER_ERROR).json({\r\n            success: false,\r\n            message: ERROR_VALUES_FETCHER.USER_FOUND_OR_NOT_CONTROLLED(AuthTypeDeclared.USER_REGISTRATION).USER_REGISTRATION_SUPPORT\r\n        });\r\n    }\r\n}\r\n\r\nexport const UserAuthPersist = async (request: Request, response: Response) => {\r\n    try {\r\n        const { registered_user_email, registered_user_password } = request.body;\r\n        const missingAttributes = MISSING_FIELDS_VALIDATOR(\r\n            { registered_user_email, registered_user_password },\r\n            response,\r\n            AuthTypeDeclared.USER_LOGIN\r\n        );\r\n        if (missingAttributes) return missingAttributes;\r\n\r\n        let userDataCaptured: any;\r\n\r\n        try {\r\n            userDataCaptured = await redisClusterConnection?.get(`user:${registered_user_email}`);\r\n            if (userDataCaptured) {\r\n                userDataCaptured = JSON.parse(userDataCaptured);\r\n                const passwordValid = await DECODING_INCOMING_SECURITY_PASSCODE(\r\n                    registered_user_password,\r\n                    userDataCaptured.password\r\n                );\r\n\r\n                if (passwordValid) {\r\n                    const tokenProvider = await JWT_KEY_GENERATION_ONBOARDED(userDataCaptured._id);\r\n                    return response.status(HTTPS_STATUS_CODE.OK).json({\r\n                        success: true,\r\n                        userInfo: userDataCaptured,\r\n                        token : tokenProvider\r\n                    });\r\n                } else {\r\n                    return response.status(HTTPS_STATUS_CODE.UNAUTHORIZED).json({\r\n                        success: false,\r\n                        message: \"Invalid email or password\"\r\n                    });\r\n                }\r\n            } else {\r\n                const trackingUser = await EXISTING_USER_FOUND_IN_DATABASE(\r\n                    registered_user_email,\r\n                    AuthTypeDeclared.USER_LOGIN,\r\n                    RolesSpecified.USER_DESC\r\n                );\r\n\r\n                // Define a type guard function to check if trackingUser is of type UserDocument\r\n                function isUserDocument(user: any): user is UserDocument {\r\n                    return (\r\n                        'registered_user_email' in user &&\r\n                        'registered_user_password' in user &&\r\n                        'registered_username' in user &&\r\n                        'authorities_provided_by_role' in user &&\r\n                        '_id' in user\r\n                    );\r\n                }\r\n\r\n                if (trackingUser && isUserDocument(trackingUser)) {\r\n                    const dataSentToRedis = {\r\n                        _id: trackingUser._id,\r\n                        email: trackingUser.registered_user_email,\r\n                        username: trackingUser.registered_username,\r\n                        password: trackingUser.registered_user_password,\r\n                        verified: trackingUser.is_user_verified,\r\n                        role: trackingUser.authorities_provided_by_role,\r\n                    };\r\n                    await redisClusterConnection?.set(`user:${registered_user_email}`, JSON.stringify(dataSentToRedis), 'EX',\r\n                        3600)\r\n                    const passcodeValid = await DECODING_INCOMING_SECURITY_PASSCODE(\r\n                        registered_user_password,\r\n                        trackingUser.registered_user_password\r\n                    );\r\n\r\n                    if (passcodeValid) {\r\n                        const token = await JWT_KEY_GENERATION_ONBOARDED(trackingUser._id);\r\n                        return response.status(HTTPS_STATUS_CODE.OK).json({\r\n                            success: true,\r\n                            userInfo: trackingUser,\r\n                            token: token,\r\n                        });\r\n                    } else {\r\n                        return response.status(HTTPS_STATUS_CODE.UNAUTHORIZED).json({\r\n                            success: false,\r\n                            message: \"Invalid email or password\",\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    return response.status(HTTPS_STATUS_CODE.NOT_FOUND).json({\r\n                        success: false,\r\n                        message: \"User not found\"\r\n                    });\r\n                }\r\n            }\r\n        } catch (err) {\r\n            console.error(\"Internal error:\", err);\r\n            return response.status(HTTPS_STATUS_CODE.INTERNAL_SERVER_ERROR).json({\r\n                success: false,\r\n                message: \"An internal error occurred while processing the request\"\r\n            });\r\n        }\r\n    } catch (err) {\r\n        console.error(\"Unexpected error:\", err);\r\n        return response.status(HTTPS_STATUS_CODE.INTERNAL_SERVER_ERROR).json({\r\n            success: false,\r\n            message: \"An unexpected error occurred\"\r\n        });\r\n    }\r\n};\r\n\r\n\r\nexport const letting_user_login = async (request: Request, response: Response) => {\r\n    try {\r\n        console.log(\"Redis pipeline type:\", typeof redisClusterConnection.pipeline); // Should log 'function'\r\n\r\n        const { registered_user_email, registered_user_password } = request.body;\r\n\r\n        let cachedUserData;\r\n\r\n        // Validate required fields\r\n        const is_exists_missing_fields = MISSING_FIELDS_VALIDATOR(\r\n            { registered_user_email, registered_user_password },\r\n            response,\r\n            AuthTypeDeclared.USER_LOGIN\r\n        );\r\n        if (is_exists_missing_fields) return is_exists_missing_fields;\r\n\r\n        // Check Redis cache for user data\r\n        try {\r\n            console.log(`Checking Redis for user data: user:${registered_user_email}`);\r\n            cachedUserData = await redisClusterConnection.get(`user:${registered_user_email}`);\r\n            console.log(\"Redis data retrieved:\", cachedUserData);\r\n        } catch (err) {\r\n            console.error('Error fetching data from Redis:', err);\r\n        }\r\n\r\n        let is_existing_database_user;\r\n\r\n        // Use cached data if available, otherwise retrieve from MongoDB\r\n        if (cachedUserData) {\r\n            console.log('User data found in Redis cache');\r\n            is_existing_database_user = JSON.parse(cachedUserData);\r\n        } else {\r\n            console.log('No cache found, querying MongoDB for user data');\r\n            is_existing_database_user = await EXISTING_USER_FOUND_IN_DATABASE(\r\n                registered_user_email,\r\n                AuthTypeDeclared.USER_LOGIN,\r\n                RolesSpecified.USER_DESC\r\n            );\r\n            console.log(\"MongoDB data retrieved:\", is_existing_database_user);\r\n\r\n            // Cache the MongoDB user data in Redis\r\n            if (is_existing_database_user) {\r\n                try {\r\n                    console.log('Caching user data in Redis');\r\n                    const userDataToCache = {\r\n                        id: is_existing_database_user._id,\r\n                        email: is_existing_database_user.registered_user_email,\r\n                        username: is_existing_database_user.registered_username,\r\n                        password: is_existing_database_user.registered_user_password,\r\n                        verified: is_existing_database_user.is_user_verified,\r\n                        role: is_existing_database_user.authorities_provided_by_role,\r\n                    };\r\n                    await redisClusterConnection.set(\r\n                        `user:${registered_user_email}`,\r\n                        JSON.stringify(userDataToCache),\r\n                        'EX',\r\n                        3600 // TTL of 1 hour\r\n                    );\r\n                } catch (err) {\r\n                    console.error('Error setting data in Redis:', err);\r\n                }\r\n            } else {\r\n                console.log('User not found in MongoDB');\r\n                return response.status(HTTPS_STATUS_CODE.UNAUTHORIZED).json({\r\n                    Error: DEFAULT_EXECUTED.MISSING_USER(RolesSpecified.USER_DESC).MESSAGE\r\n                });\r\n            }\r\n        }\r\n\r\n        console.log(\"User data for validation:\", is_existing_database_user);\r\n\r\n        // Password validation logic\r\n        const is_password_valid = await DECODING_INCOMING_SECURITY_PASSCODE(\r\n            registered_user_password,\r\n            is_existing_database_user.password || is_existing_database_user.registered_user_password\r\n        );\r\n\r\n        console.log('Password validation result:', is_password_valid);\r\n\r\n        if (is_password_valid) {\r\n            const token_for_authentication_generated = await JWT_KEY_GENERATION_ONBOARDED(is_existing_database_user._id);\r\n            return response.status(HTTPS_STATUS_CODE.OK).json({\r\n                success: true,\r\n                message: [{\r\n                    SUCCESS_MESSAGE: SUCCESS_VALUES_FETCHER.ENTITY_ONBOARDED_FULFILED(AuthTypeDeclared.USER_LOGIN, RolesSpecified.USER_DESC).SUCCESS_MESSAGE,\r\n                    USER_ROLE: RolesSpecified.USER_DESC,\r\n                    AUTH_TYPE: AuthTypeDeclared.USER_LOGIN\r\n                }],\r\n                userInfo: is_existing_database_user,\r\n                token: token_for_authentication_generated\r\n            });\r\n        } else {\r\n            console.log('Invalid password');\r\n            return response.status(HTTPS_STATUS_CODE.UNAUTHORIZED).json({\r\n                Error: ERROR_VALUES_FETCHER.INVALID_CREDENTIALS_PROVIDED(RolesSpecified.USER_DESC)\r\n            });\r\n        }\r\n\r\n    } catch (error: any) {\r\n        console.error('Error in letting_user_login:', error);\r\n        return response.status(HTTPS_STATUS_CODE.INTERNAL_SERVER_ERROR).json({\r\n            Error: 'An error occurred during login. Please try again later.',\r\n            Details: error.message\r\n        });\r\n    }\r\n};\r\n\r\nexport const get_user_profile = async (request: AuthenticatedRequest, response: Response) => {\r\n    try {\r\n        console.log(\"Function get_user_profile called\");\r\n        console.log(\"User email from request:\", request.user?.registered_user_email);\r\n        let cachedUserData = await redisClusterConnection.get(`user:${request.user?.registered_user_email}`);\r\n        if ( cachedUserData){\r\n\r\n            return response.status(HTTPS_STATUS_CODE.OK).json({\r\n                success: true,\r\n                userInfo: JSON.parse(cachedUserData),\r\n            })\r\n        }\r\n        else {\r\n            const userDataCaptured = await EXISTING_USER_FOUND_IN_DATABASE(\r\n                request?.user?.registered_user_email,\r\n                AuthTypeDeclared.USER_LOGIN,\r\n                RolesSpecified.USER_DESC\r\n            );\r\n            if ( userDataCaptured){\r\n\r\n                return response.status(HTTPS_STATUS_CODE.OK).json({\r\n                    success: true,\r\n                    userInfo: userDataCaptured,\r\n                })\r\n            }\r\n        }\r\n        // if ( cachedUserData){\r\n        //     return response.status(HTTPS_STATUS_CODE.NOT_FOUND).json({\r\n        //         // success: false,\r\n        //         message: DEFAULT_EXECUTED.MISSING_USER(RolesSpecified.USER_DESC).MESSAGE\r\n        //     });\r\n        // }\r\n        // else {\r\n        //     const fetched_loggedin_user = request.user;\r\n        //     console.log(\"Fallback to user data from request:\", fetched_loggedin_user);\r\n\r\n        //     if (!fetched_loggedin_user) {\r\n        //         throw new Error(DEFAULT_EXECUTED.MISSING_USER(RolesSpecified.USER_DESC).MESSAGE);\r\n        //     }\r\n\r\n        //     console.log(\"Returning user data from request\");\r\n        //     return response.status(HTTPS_STATUS_CODE.OK).json({\r\n        //         success: true,\r\n        //         message: SUCCESS_VALUES_FETCHER.RETRIEVED_ENTITY_SESSION(RolesSpecified.USER_DESC).SUCCESS_MESSAGE,\r\n        //         userInfo: fetched_loggedin_user\r\n        //     });\r\n        // }\r\n\r\n        // try {\r\n        //     console.log(\"Attempting to fetch data from Redis...\");\r\n        //     cachedUserData = \r\n        //     console.log(\"Fetched data from Redis:\", cachedUserData);\r\n        // } catch (err) {\r\n        //     console.error('Error fetching data from Redis:', err);\r\n        // }\r\n\r\n        console.log(\"Checking Redis data...\");\r\n        // if (cachedUserData) {\r\n        //     console.log(\"Redis data exists, parsing...\");\r\n        //     const parsedData = JSON.parse(cachedUserData);\r\n        //     if (parsedData === null || parsedData === \"user not found\") {\r\n        //         console.log('User not found in Redis cache');\r\n        //         return response.status(HTTPS_STATUS_CODE.NOT_FOUND).json({\r\n        //             success: false,\r\n        //             message: DEFAULT_EXECUTED.MISSING_USER(RolesSpecified.USER_DESC).MESSAGE\r\n        //         });\r\n        //     }\r\n\r\n        //     console.log('User data retrieved from Redis cache:', parsedData);\r\n        //     return response.status(HTTPS_STATUS_CODE.OK).json({\r\n        //         success: true,\r\n        //         message: SUCCESS_VALUES_FETCHER.RETRIEVED_ENTITY_SESSION(RolesSpecified.USER_DESC).SUCCESS_MESSAGE,\r\n        //         userInfo: parsedData\r\n        //     });\r\n        // }\r\n\r\n        // Fallback if Redis does not contain user data\r\n\r\n\r\n    } catch (error_value_displayed) {\r\n        console.log(\"hi\")\r\n        console.error('Error in get_user_profile:', error_value_displayed);\r\n        return response.status(HTTPS_STATUS_CODE.INTERNAL_SERVER_ERROR).json({\r\n            Error: DEFAULT_EXECUTED.ERROR,\r\n            details: (error_value_displayed as Error).message,\r\n            // NOTFOUND: DEFAULT_EXECUTED.MISSING_USER(RolesSpecified.USER_DESC).MESSAGE\r\n        });\r\n    }\r\n};\r\n\r\n\r\nexport const verify_email_provided_user = async (request: AuthenticatedRequest, response: Response) => {\r\n    try {\r\n        const { otp_for_verification } = request.body;\r\n        if (!otp_for_verification) {\r\n            return response.status(400).json({ Error: \"Please provide otp\" });\r\n        }\r\n        const stored_token_for_user_request = await OTP_GENERATOR_CALLED(otp_for_verification, request.user.otp_for_verification)\r\n\r\n        if (stored_token_for_user_request) {\r\n            request.user.otp_for_verification = \"\";\r\n            request.user.is_user_verified = true;\r\n\r\n            await request.user.save();\r\n\r\n            return response.status(200).json({ success: true, message: \"Email verified successfully\" });\r\n        } else {\r\n            return response.status(400).json({ Error: \"Invalid OTP, please try again\" });\r\n        }\r\n\r\n    } catch (error_value_displayed) {\r\n        console.error(error_value_displayed);\r\n        return response.status(500).json({ Error: 'Something went wrong, try again later', details: (error_value_displayed as Error).message });\r\n    }\r\n}\r\nexport const resend_otp_for_verification_request = async (request: AuthenticatedRequest, response: Response) => {\r\n    try {\r\n        const fetched_loggedin_user = request.user;\r\n        if (!fetched_loggedin_user) throw new Error(DEFAULT_EXECUTED.MISSING_USER(RolesSpecified.USER_DESC).MESSAGE);\r\n\r\n        if (!fetched_loggedin_user.is_user_verified) {\r\n            const redefining_otp_generation = OTP_GENERATOR_CALLED(request.user.otp_for_verification, request.user.otp_for_verification)\r\n            fetched_loggedin_user.otp_for_verification = redefining_otp_generation;\r\n            await fetched_loggedin_user.save();\r\n\r\n            await email_service_enabled({\r\n                senders_email: process.env.SENDER_EMAIL || '',\r\n                receivers_email: fetched_loggedin_user.registered_user_email,\r\n                otp_for_verification: fetched_loggedin_user.otp_for_verification,\r\n                product_by_company: process.env.PRODUCT_NAME || '',\r\n                receivers_username: fetched_loggedin_user.registered_username\r\n            });\r\n\r\n            return response.status(200).json({\r\n                success: true,\r\n                message: \"OTP sent successfully\",\r\n                updated_user_profile_otp: fetched_loggedin_user\r\n            });\r\n\r\n        } else {\r\n            return response.status(400).json({ Error: \"User already verified\" });\r\n        }\r\n\r\n    } catch (error_value_displayed) {\r\n        console.error(error_value_displayed);\r\n        return response.status(500).json({\r\n            Error: 'Something went wrong, try again later',\r\n            details: (error_value_displayed as Error).message\r\n        });\r\n    }\r\n}\r\n\r\nexport const reset_password_for_verified_user = async (request: AuthenticatedRequest, response: Response) => {\r\n    try {\r\n        const fetched_loggedin_user = request.user;\r\n        if (!fetched_loggedin_user) throw new Error();\r\n        if (fetched_loggedin_user.is_user_verified) {\r\n            const { registered_user_password } = request.body;\r\n            const is_same_password_for_user = await bcrypt.compare(registered_user_password, fetched_loggedin_user.registered_user_password)\r\n            if (!is_same_password_for_user) {\r\n                const salted_credentials = await bcrypt.genSalt(10);\r\n                const hashed_password_generated = await bcrypt.hash(registered_user_password, salted_credentials);\r\n                fetched_loggedin_user.registered_user_password = hashed_password_generated;\r\n                await fetched_loggedin_user.save()\r\n\r\n                return response.status(200).json({\r\n                    success: true,\r\n                    message: \"Password Updated successfully\",\r\n                    updated_user_profile_password: fetched_loggedin_user\r\n                });\r\n            }\r\n            else {\r\n                return response.status(400).json({ Error: \"Password can't be same as previous password use different one\" });\r\n            }\r\n\r\n        } else {\r\n            return response.status(400).json({ Error: \"Password can't be reset at this moment\" });\r\n        }\r\n    } catch (error_value_displayed) {\r\n        return response.status(500).json({ Error: 'Something went wrong, try again later', details: (error_value_displayed as Error).message });\r\n    }\r\n}\r\n\r\n"]}