{"version":3,"file":"CommonFunctions.js","sourceRoot":"/","sources":["Constants/Functions/CommonFunctions.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,iEAAkE;AAClE,MAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAA;AAChC,MAAM,GAAG,GAAG,OAAO,CAAC,cAAc,CAAC,CAAA;AAC5B,MAAM,oBAAoB,GAAG,CAAM,6BAAqC,EAAE,oBAA0B,EAAC,EAAE;IAC1G,OAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAC;AACnE,CAAC,CAAA,CAAA;AAFY,QAAA,oBAAoB,wBAEhC;AACM,MAAM,iBAAiB,GAAG,CAAM,6BAAqC,EAAE,EAAE;IAE5E,MAAM,kBAAkB,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IACpD,OAAO,MAAM,MAAM,CAAC,IAAI,CAAC,6BAA6B,EAAE,kBAAkB,CAAC,CAAC;AAChF,CAAC,CAAA,CAAA;AAJY,QAAA,iBAAiB,qBAI7B;AACM,MAAM,mCAAmC,GAAG,CAAM,qBAA6B,EAAG,wBAAgC,EAAC,EAAE;IACxH,OAAO,MAAM,MAAM,CAAC,OAAO,CAAC,qBAAqB,EAAE,wBAAwB,CAAC,CAAC;AACjF,CAAC,CAAA,CAAA;AAFY,QAAA,mCAAmC,uCAE/C;AAEM,MAAM,oBAAoB,GAAG,CAAO,wBAAiC,EAAG,8BAAuC,EAAE,EAAE;IACtH,OAAO,CAAE,CAAC,wBAAwB,KAAM,CAAC,8BAA8B,CAAC,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,CAAC,KAAK,CAAA;AAC5F,CAAC,CAAA,CAAA;AAFY,QAAA,oBAAoB,wBAEhC;AAEM,MAAM,4BAA4B,GAAG,CAAM,iBAA0B,EAAG,EAAE;IAC7E,MAAM,kBAAkB,GAAG,OAAO,CAAC,GAAG,CAAC,uBAAuB,CAAC;IAC3D,IAAI,CAAC,kBAAkB;QAAE,MAAM,IAAI,KAAK,CAAC,uCAAoB,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;IACpG,OAAQ,GAAG,CAAC,IAAI,CACZ,EAAE,EAAE,EAAE,iBAAiB,EAAE,EACzB,kBAAkB,EAClB,EAAE,SAAS,EAAE,OAAO,CAAC,GAAG,CAAC,wBAAwB,IAAI,KAAK,EAAE,CAC/D,CAAC;AACV,CAAC,CAAA,CAAA;AARY,QAAA,4BAA4B,gCAQxC","sourcesContent":["import { response } from \"express\";\r\nimport { ERROR_VALUES_FETCHER } from \"../Errors/PreDefinedErrors\";\r\nconst bcrypt = require('bcrypt')\r\nconst jwt = require('jsonwebtoken')\r\nexport const OTP_GENERATOR_CALLED = async(entered_password_registration: string, otp_for_verification?: any)=>{\r\n    return  Math.floor(100000 + Math.random() * 900000).toString();\r\n}\r\nexport const SECURING_PASSCODE = async(entered_password_registration: string) =>{\r\n    \r\n    const salted_credentials = await bcrypt.genSalt(10);\r\n    return await bcrypt.hash(entered_password_registration, salted_credentials);\r\n}\r\nexport const DECODING_INCOMING_SECURITY_PASSCODE = async(user_entered_password: string , user_registered_password: string)=>{\r\n    return await bcrypt.compare(user_entered_password, user_registered_password);\r\n}\r\n\r\nexport const OTP_VALIDATOR_SETTLE = async( user_entered_otp_request : string , software_generated_otp_request : string )=>{\r\n    return ( +user_entered_otp_request ===  +software_generated_otp_request) ?  true : false\r\n}\r\n\r\nexport const JWT_KEY_GENERATION_ONBOARDED = async(user_generated_id : string ) =>{\r\n    const SECRET_KEY_FETCHED = process.env.JWT_SECRET_KEY_ATTACHED;\r\n        if (!SECRET_KEY_FETCHED) throw new Error(ERROR_VALUES_FETCHER.JWT_DETECTED_ERRORS.JWT_NOT_DETECTED);\r\n        return  jwt.sign(\r\n            { id: user_generated_id },\r\n            SECRET_KEY_FETCHED,\r\n            { expiresIn: process.env.JWT_EXPIRY_DATE_ASSIGNED || '30d' }\r\n        );\r\n}"]}